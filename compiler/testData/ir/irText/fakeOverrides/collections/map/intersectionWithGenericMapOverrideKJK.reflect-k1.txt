KClass: B
  members:
    fun B<T>.clear(): kotlin.Unit
    fun B<T>.comparator(): java.util.Comparator<in T!>!
    fun B<T>.compute(T!, java.util.function.BiFunction<in T!, in T?, out T?>): T?
    fun B<T>.computeIfAbsent(T!, java.util.function.Function<in T!, out T!>): T!
    fun B<T>.computeIfPresent(T!, java.util.function.BiFunction<in T!, in T, out T?>): T?
    fun B<T>.containsKey(T!): kotlin.Boolean
    fun B<T>.containsValue(T!): kotlin.Boolean
    fun B<T>.equals(kotlin.Any?): kotlin.Boolean
    fun B<T>.firstKey(): T!
    fun B<T>.forEach(java.util.function.BiConsumer<in T!, in T!>): kotlin.Unit
    fun B<T>.get(T!): T?
    fun B<T>.getOrDefault(T, T): T
    fun B<T>.hashCode(): kotlin.Int
    fun B<T>.headMap(T!): java.util.SortedMap<T!, T!>!
    fun B<T>.isEmpty(): kotlin.Boolean
    fun B<T>.lastKey(): T!
    fun B<T>.merge(T!, T, java.util.function.BiFunction<in T, in T, out T?>): T?
    fun B<T>.put(T, T): T
    fun B<T>.putAll(kotlin.collections.Map<out T!, T!>): kotlin.Unit
    fun B<T>.putIfAbsent(T!, T!): T?
    fun B<T>.remove(T!, T!): kotlin.Boolean
    fun B<T>.remove(T): T
    fun B<T>.replace(T!, T!): T?
    fun B<T>.replace(T!, T!, T!): kotlin.Boolean
    fun B<T>.replaceAll(java.util.function.BiFunction<in T!, in T!, out T!>): kotlin.Unit
    fun B<T>.subMap(T!, T!): java.util.SortedMap<T!, T!>!
    fun B<T>.tailMap(T!): java.util.SortedMap<T!, T!>!
    fun B<T>.toString(): kotlin.String
    val B<T>.entries: kotlin.collections.MutableSet<kotlin.collections.MutableMap.MutableEntry<T!, T!>>
    val B<T>.keys: kotlin.collections.MutableSet<T!>
    val B<T>.size: kotlin.Int
    val B<T>.values: kotlin.collections.MutableCollection<T!>
  declaredMembers:
    fun B<T>.put(T, T): T
    fun B<T>.remove(T): T
KPackage: _1Kt
  fun test(A<kotlin.Boolean>, B<kotlin.Boolean?>): kotlin.Unit
KClass: A
  members:
    fun A<T>.clear(): kotlin.Unit
    fun A<T>.comparator(): java.util.Comparator<in T!>!
    fun A<T>.compute(T!, java.util.function.BiFunction<in T!, in T?, out T?>): T?
    fun A<T>.computeIfAbsent(T!, java.util.function.Function<in T!, out T!>): T!
    fun A<T>.computeIfPresent(T!, java.util.function.BiFunction<in T!, in T, out T?>): T?
    fun A<T>.containsKey(T!): kotlin.Boolean
    fun A<T>.containsValue(T!): kotlin.Boolean
    fun A<T>.equals(kotlin.Any?): kotlin.Boolean
    fun A<T>.firstKey(): T!
    fun A<T>.forEach(java.util.function.BiConsumer<in T!, in T!>): kotlin.Unit
    fun A<T>.get(T!): T?
    fun A<T>.getOrDefault(T, T): T
    fun A<T>.hashCode(): kotlin.Int
    fun A<T>.headMap(T!): java.util.SortedMap<T!, T!>!
    fun A<T>.isEmpty(): kotlin.Boolean
    fun A<T>.lastKey(): T!
    fun A<T>.merge(T!, T, java.util.function.BiFunction<in T, in T, out T?>): T?
    fun A<T>.put(T!, T!): T?
    fun A<T>.putAll(kotlin.collections.Map<out T!, T!>): kotlin.Unit
    fun A<T>.putIfAbsent(T!, T!): T?
    fun A<T>.remove(T!): T?
    fun A<T>.remove(T!, T!): kotlin.Boolean
    fun A<T>.replace(T!, T!): T?
    fun A<T>.replace(T!, T!, T!): kotlin.Boolean
    fun A<T>.replaceAll(java.util.function.BiFunction<in T!, in T!, out T!>): kotlin.Unit
    fun A<T>.subMap(T!, T!): java.util.SortedMap<T!, T!>!
    fun A<T>.tailMap(T!): java.util.SortedMap<T!, T!>!
    fun A<T>.toString(): kotlin.String
    val A<T>.entries: kotlin.collections.MutableSet<kotlin.collections.MutableMap.MutableEntry<T!, T!>>
    val A<T>.keys: kotlin.collections.MutableSet<T!>
    val A<T>.size: kotlin.Int
    val A<T>.values: kotlin.collections.MutableCollection<T!>
  declaredMembers:
