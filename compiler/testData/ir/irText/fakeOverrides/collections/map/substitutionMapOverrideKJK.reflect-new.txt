KClass: Java1
  members:
    fun Java1<T>.clear(): kotlin.Unit
    fun Java1<T>.clone(): kotlin.Any!
    fun Java1<T>.containsKey(K): kotlin.Boolean
    fun Java1<T>.containsKey(T!): kotlin.Boolean
    fun Java1<T>.containsValue(T!): kotlin.Boolean
    fun Java1<T>.containsValue(V): kotlin.Boolean
    fun Java1<T>.equals(kotlin.Any?): kotlin.Boolean
    fun Java1<T>.forEach(java.util.function.BiConsumer<in K, in V>): kotlin.Unit
    fun Java1<T>.get(K): V?
    fun Java1<T>.get(T!): T?
    fun Java1<T>.getOrDefault(K, V): V
    fun Java1<T>.hashCode(): kotlin.Int
    fun Java1<T>.isEmpty(): kotlin.Boolean
    fun Java1<T>.put(T, T): T?
    fun Java1<T>.putAll(kotlin.collections.Map<out T!, T!>): kotlin.Unit
    fun Java1<T>.remove(T!): T?
    fun Java1<T>.toString(): kotlin.String
    val Java1<T>.entries: kotlin.collections.Set<kotlin.collections.Map.Entry<K, V>>
    val Java1<T>.keys: kotlin.collections.Set<K>
    val Java1<T>.size: kotlin.Int
    val Java1<T>.values: kotlin.collections.Collection<V>
  declaredMembers:
KClass: B
  members:
    fun B<T>.clear(): kotlin.Unit
    fun B<T>.clone(): kotlin.Any!
    fun B<T>.containsKey(K): kotlin.Boolean
    fun B<T>.containsKey(T!): kotlin.Boolean
    fun B<T>.containsValue(T!): kotlin.Boolean
    fun B<T>.containsValue(V): kotlin.Boolean
    fun B<T>.equals(kotlin.Any?): kotlin.Boolean
    fun B<T>.forEach(java.util.function.BiConsumer<in K, in V>): kotlin.Unit
    fun B<T>.get(K): V?
    fun B<T>.get(T!): T?
    fun B<T>.getOrDefault(K, V): V
    fun B<T>.hashCode(): kotlin.Int
    fun B<T>.isEmpty(): kotlin.Boolean
    fun B<T>.put(T, T): T?
    fun B<T>.putAll(kotlin.collections.Map<out T!, T!>): kotlin.Unit
    fun B<T>.remove(T!): T?
    fun B<T>.toString(): kotlin.String
    val B<T>.entries: kotlin.collections.MutableSet<kotlin.collections.MutableMap.MutableEntry<T, T>>
    val B<T>.keys: kotlin.collections.Set<K>
    val B<T>.size: kotlin.Int
    val B<T>.values: kotlin.collections.Collection<V>
  declaredMembers:
    fun B<T>.put(T, T): T?
    val B<T>.entries: kotlin.collections.MutableSet<kotlin.collections.MutableMap.MutableEntry<T, T>>
KPackage: _1Kt
  fun test(A<kotlin.Boolean>, B<kotlin.Boolean?>): kotlin.Unit
KClass: A
  members:
    fun A<T>.clear(): kotlin.Unit
    fun A<T>.clone(): kotlin.Any!
    fun A<T>.containsKey(K): kotlin.Boolean
    fun A<T>.containsKey(T!): kotlin.Boolean
    fun A<T>.containsValue(T!): kotlin.Boolean
    fun A<T>.containsValue(V): kotlin.Boolean
    fun A<T>.equals(kotlin.Any?): kotlin.Boolean
    fun A<T>.forEach(java.util.function.BiConsumer<in K, in V>): kotlin.Unit
    fun A<T>.get(K): V?
    fun A<T>.get(T!): T?
    fun A<T>.getOrDefault(K, V): V
    fun A<T>.hashCode(): kotlin.Int
    fun A<T>.isEmpty(): kotlin.Boolean
    fun A<T>.put(T, T): T?
    fun A<T>.putAll(kotlin.collections.Map<out T!, T!>): kotlin.Unit
    fun A<T>.remove(T!): T?
    fun A<T>.toString(): kotlin.String
    val A<T>.entries: kotlin.collections.Set<kotlin.collections.Map.Entry<K, V>>
    val A<T>.keys: kotlin.collections.Set<K>
    val A<T>.size: kotlin.Int
    val A<T>.values: kotlin.collections.Collection<V>
  declaredMembers:
